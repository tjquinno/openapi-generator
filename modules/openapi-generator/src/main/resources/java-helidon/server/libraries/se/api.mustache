package {{package}};

{{#imports}}import {{import}};
{{/imports}}

{{#useAbstractClass}}
import java.util.Optional;
{{#x-helidon-v3}}
import java.util.logging.Logger;
{{/x-helidon-v3}}

import io.helidon.common.GenericType;
{{^x-helidon-v3}}
import io.helidon.common.Errors;
{{/x-helidon-v3}}
{{#x-helidon-v3}}
import io.helidon.common.reactive.Single;
{{/x-helidon-v3}}
{{/useAbstractClass}}
{{#x-helidon-v3}}
import io.helidon.webserver.Routing;
{{/x-helidon-v3}}
{{^x-helidon-v3}}
import io.helidon.webserver.http.HttpRules;
{{/x-helidon-v3}}
import io.helidon.webserver.{{^x-helidon-v3}}http.{{/x-helidon-v3}}ServerRequest;
import io.helidon.webserver.{{^x-helidon-v3}}http.{{/x-helidon-v3}}ServerResponse;
import io.helidon.webserver.{{^x-helidon-v3}}http.Http{{/x-helidon-v3}}Service;
{{#useBeanValidation}}{{^x-helidon-v3}}import {{rootJavaEEPackage}}.validation.constraints.*;
import {{rootJavaEEPackage}}.validation.Valid;
{{/x-helidon-v3}}{{/useBeanValidation}}{{!
}}{{^x-helidon-v3}}import {{rootJavaEEPackage}}.validation.ValidationException;
{{/x-helidon-v3}}{{!
}}{{#x-helidon-hasGenericTypeDeclarations}}import {{modelPackage}}.GenericTypes;
{{/x-helidon-hasGenericTypeDeclarations}}{{!
}}
{{#operations}}
{{^useAbstractClass}}public interface {{classname}} extends {{^x-helidon-v3}}Http{{/x-helidon-v3}}Service { {{/useAbstractClass}}
{{#useAbstractClass}}public abstract class {{classname}} implements {{^x-helidon-v3}}Http{{/x-helidon-v3}}Service {

    protected static final {{^x-helidon-v3}}System.{{/x-helidon-v3}}Logger LOGGER = {{^x-helidon-v3}}System{{/x-helidon-v3}}{{#x-helidon-v3}}Logger{{/x-helidon-v3}}.getLogger({{classname}}.class.getName());
{{#jackson}}
    protected static final ObjectMapper MAPPER = JsonProvider.objectMapper();{{/jackson}}
{{#jsonb}}
    protected static final Jsonb JSONB = JsonbBuilder.create();{{/jsonb}}
{{/useAbstractClass}}

{{#x-helidon-v3}}
    /**
     * A service registers itself by updating the routing rules.
     * @param rules the routing rules.
     */
{{/x-helidon-v3}}
{{^x-helidon-v3}}
    /**
     * Updates the routing rules to dispatch requests to the generated code.
     *
     * @param rules the routing rules
     */
{{/x-helidon-v3}}
    @Override
    {{#useAbstractClass}}public{{/useAbstractClass}}{{^useAbstractClass}}default{{/useAbstractClass}} void {{#x-helidon-v3}}update{{/x-helidon-v3}}{{^x-helidon-v3}}routing{{/x-helidon-v3}}({{#x-helidon-v3}}Routing.{{/x-helidon-v3}}{{^x-helidon-v3}}Http{{/x-helidon-v3}}Rules rules) {
{{#operation}}
        rules.{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}("{{{path}}}", {{!
}}{{#bodyParam}}{{#x-helidon-v3}}{{#isModel}}Handler.create({{{dataType}}}.class, {{/isModel}}{{/x-helidon-v3}}this::{{{operationId}}}){{#isModel}}{{#x-helidon-v3}}){{/x-helidon-v3}}{{/isModel}}{{/bodyParam}}{{!
}}{{^bodyParam}}this::{{{operationId}}}){{/bodyParam}};
{{/operation}}
    }
{{#x-helidon-v3}}{{#useAbstractClass}}{{#isFormParamsFunctions}}

    {{!}}{{>formParamsFunctions}}
{{/isFormParamsFunctions}}{{/useAbstractClass}}{{/x-helidon-v3}}
{{#operation}}

{{#x-helidon-v3}}
    /**
     * {{httpMethod}} {{{path}}}{{#summary}} : {{.}}{{/summary}}.
     * @param request the server request
     * @param response the server response{{#allParams}}{{#isBodyParam}}{{#isModel}}
     * @param {{paramName}} {{{description}}}{{^description}}{{paramName}}{{/description}} {{/isModel}}{{/isBodyParam}}{{/allParams}}
     */
    void {{{operationId}}}(ServerRequest request, ServerResponse response{{#allParams}}{{#isBodyParam}}{{#isModel}}, {{{dataType}}} {{paramName}}{{/isModel}}{{/isBodyParam}}{{/allParams}}){{^useAbstractClass}};{{/useAbstractClass}}{{#useAbstractClass}} { {{#formParams}}{{#-first}}
        {{>formParamsInitial}}{{/-first}}{{/formParams}}
        Single.create({{^hasParams}}Single.empty(){{/hasParams}}{{#hasParams}}{{^bodyParam}}{{#formParams}}{{#-first}}formSingle{{/-first}}{{/formParams}}{{^formParams}}Single.empty(){{/formParams}}{{/bodyParam}}{{#bodyParam}}{{^isModel}}request.content().as(new GenericType<{{{dataType}}}>() { }){{/isModel}}{{#isModel}}Single.empty(){{/isModel}}{{/bodyParam}}{{/hasParams}})
            .thenAccept({{#bodyParam}}{{^isModel}}{{paramName}}{{/isModel}}{{#isModel}}val{{/isModel}}{{/bodyParam}}{{^bodyParam}}val{{/bodyParam}} -> {
{{#allParams}}
                {{> queryParams }}{{> pathParams }}{{> headerParams}}{{> bodyParams}}{{> formParams}}{{> cookieParams}}
{{/allParams}}
                handle{{#lambda.titlecase}}{{{operationId}}}{{/lambda.titlecase}}(request, response{{#allParams}}, {{paramName}}{{/allParams}});
            })
            .exceptionally(throwable -> handleError(request, response, throwable));
    }

    /**
     * Handle {{httpMethod}} {{{path}}}{{#summary}} : {{.}}{{/summary}}.
     * @param request the server request
     * @param response the server response{{#allParams}}
     * @param {{paramName}} {{{description}}}{{^description}}{{paramName}}{{/description}} {{/allParams}}
     */
    abstract void handle{{#lambda.titlecase}}{{{operationId}}}{{/lambda.titlecase}}(ServerRequest request, ServerResponse response{{#allParams}}, {{>dataType}} {{paramName}}{{/allParams}});
{{/useAbstractClass}}
{{/x-helidon-v3}}
{{^x-helidon-v3}}
    {{#useAbstractClass}}public{{/useAbstractClass}}{{^useAbstractClass}}default{{/useAbstractClass}} void {{{operationId}}}(ServerRequest request, ServerResponse response) {
    {{!

      If the operation has form parameters we need to generate code to process the request body as form data, creating a Helidon
      Parameters object we can use to assign the individual form variables. That is, unless the body is multipart in which case
      we handle things differently.

    }}{{^isMultipart}}{{#formParams}}{{#-first}}        Parameters formParams = request.content().as(Parameters.class);

    {{/-first}}{{/formParams}}{{/isMultipart}}{{!
}}{{#isMultipart}}        MultiPart multiPart = request.content().as(MultiPart.class);
    multiPart.forEachRemaining(part -> {
    // TODO: Insert user-implemented handling of multipart data here.
    });
    {{/isMultipart}}{{!
}}        ValidatorUtils.Validator validator = ValidatorUtils.validator(LOGGER);
    {{#allParams}}{{!
}}{{#isMap}}
        // TODO - user code needed to handle Map for {{#isHeaderParam}}header{{/isHeaderParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isFormParam}}form{{/isFormParam}}{{#isBodyParam}}body{{/isBodyParam}}{{#isCookieParam}}cookie{{/isCookieParam}} parameter {{paramName}}.{{/isMap}}{{!
}}{{^isMap}}{{!
}}{{!

    We handle form parameters separately here because we handle multipart separate from single part form params.

}}{{^isFormParam}}{{!
}}{{^isBodyParam}}
        {{>paramDecl}} = {{>paramValue}};{{!
}}{{/isBodyParam}}{{!
}}{{#isBodyParam}}{{!
}}{{^isFile}}
        {{>paramDecl}} = {{>bodyParamValue}};{{!
}}{{/isFile}}{{!
}}{{#isFile}}
        InputStream {{paramName}} = request.content().inputStream;{{!
}}{{/isFile}}
    {{/isBodyParam}}{{!
}}{{/isFormParam}}{{!
}}{{#isFormParam}}{{^isMultipart}}
        {{>paramDecl}} = {{>paramValue}};{{!
}}{{/isMultipart}}{{/isFormParam}}{{!
}}{{/isMap}}{{!
}}{{/allParams}}
    validator.execute();

    handle{{#lambda.titlecase}}{{operationId}}{{/lambda.titlecase}}(request, response{{#allParams}},
    {{paramName}}{{/allParams}});
{{/x-helidon-v3}}

{{/operation}}
{{#x-helidon-v3}}
{{#useAbstractClass}}    abstract Void handleError(ServerRequest request, ServerResponse response, Throwable throwable);{{!
}}{{/useAbstractClass}}
{{/x-helidon-v3}}
{{^x-helidon-v3}}
    @Override
    public void afterStop() {
    System.out.println("Service {{classname}} is down. Goodbye!");
    }
{{/x-helidon-v3}}{{!
}}{{^x-helidon-v3}}{{!
}}{{#operation}}
    {{#useAbstractClass}}protected abstract {{/useAbstractClass}}void handle{{#lambda.titlecase}}{{operationId}}{{/lambda.titlecase}}(ServerRequest serverRequest, ServerResponse serverResponse{{!
}}{{#allParams}},
                {{> paramDecl }}{{/allParams}});
{{/operation}}{{!
}}{{/x-helidon-v3}}}
{{/operations}}
